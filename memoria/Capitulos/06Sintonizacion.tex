%---------------------------------------------------------------------
%
%                          Capítulo 6
%
%---------------------------------------------------------------------

\chapter{Sintonización}
\label{cap6}
%\begin{FraseCelebre}
%\begin{Frase}
%She's up all night to the sun\\
%I'm up all night to get some\\
%%she's up all night for good fun\\
%I'm up all night to get lucky 
%\end{Frase}
%\begin{Fuente}
%Thomas \& Guy-Manuel, Daft Punk
%\end{Fuente}
%\end{FraseCelebre}%%

\begin{resumen}

\end{resumen}

%-------------------------------------------------------------------
\section{Introducción}
%-------------------------------------------------------------------
\label{cap6:sec:testModel}
%-------------------------------------------------------------------
En este capitulo se va a tratar la parte más importante del proyecto, la parte donde se diferencia de otros generadores ya construidos. El hecho de que el propio generador sea capaz de modificar sus características físicas para adaptarse a su entorno y obtener de él el máximo de energía posible le confiere unas propiedades únicas.

En concreto para este generador la mejor opción de sintonización pasa por modificar la longitud efectiva de la lámina como se verá a continuación, aun así se estudiaran diferentes alternativas que existen para obtener el máximo de energía del entorno en cada momento.

%-------------------------------------------------------------------
\section{Sintonización}
%-------------------------------------------------------------------
\label{cap6:sec:sinto}
%-------------------------------------------------------------------


El objetivo que se quiere cumplir cuando se construye un generador de ''Energy Harvesting'' es la máxima extracción de energía del entorno. Dependiendo del tipo de generador existen distintas formas de maximizar esta energía. A continuación se trataran las que existen para los generadores a partir de vibraciones como el que nos ocupa.

\subsection{Medios para maximizar la recolección} 

Partiendo del hecho de que los generadores a partir de vibraciones tienen un factor de calidad (Q) muy alto, es decir un ancho de banda muy reducido, se han propuesto diferentes estudios \cite{sintonization} que han resultado en dos modos de maximizar la energía extraída, los cuales son, aumentar el ancho de banda del sistema, y \textbf{sintonizar} el sistema.

\subsubsection{Aumentar el ancho de banda} 

La primera opción es construir un sistema con varios generadores de alta Q en paralelo, cada uno diseñado para trabajar a una frecuencia de resonancia distinta del resto. Este tipo de configuración produciría energía siempre y cuando la frecuencia de vibración del entorno coincida con alguna de las frecuencias de resonancia de los generadores, si esto no sucediese, no se podría obtener energía del medio puesto que las frecuencias de resonancia son fijas, a esto hay que añadirle el coste de fabricación y espacio que supondría el uso de varios generadores en un mismo sistema.
En \citep{filterband} se desarrolló un dispositivo que consistía en varios de estos generadores, diseñados de tal manera que actuaban como un filtro paso banda en vibraciones.
\begin{figure}[!h]
        \centering
		\includegraphics[width=0.6\textwidth]{Imagenes/imagenes/cap6/genarray}  
        \caption{Ejemplo de función de transferencia de este sistema multigenerador.}
        \label{fig:cap6:array}
\end{figure}

-Otra estrategia para aumentar el ancho de banda es fabricar generadores no lineales.
Esto se consigue mediante la introducción de imanes que alteran el movimiento de la masa en el extremo (otro imán). De esta manera el movimiento no es lineal estando sobreamortiguado.
\begin{figure}[!h]
        \centering
		\includegraphics[width=0.4\textwidth]{Imagenes/imagenes/cap6/nolineal}  
        \caption{Generador no lineal con masa magnética suspendida en un campo magnético.}
        \label{fig:cap6:nolinea}
\end{figure}
\FloatBarrier
Estos generadores no se basan en el modelo de segundo orden visto hasta ahora sino en las ecuaciones de Duffing.
$$m\frac{d^{2}Z(t)}{dt^{2}}+b\frac{dZ(t)}{dt}+KZ(t)+K_{n}[Z(t)]^{3}=-m\frac{d^{2}y(t)}{dt^{2}}$$

Donde la fuerza ejercida sobre la masa es la combinación de la fuerza lineal $kz(t)$ y la fuerza no lineal $kn[z(t)]^{3}$.

Esta componente no lineal viene producida por los imanes fijos que repelen el imán móvil, de esta manera éste tiende a la posición de equilibrio por la suma de estas dos fuerzas.
\\
\\
-Otros dos métodos para aumentar el ancho de banda son \textbf{limitar la amplitud} o \textbf{acoplar osciladores.}

Para limitar la amplitud se coloca un tope en uno de los lados de la lámina produciendo una sobre-deformación al limitar el tome el movimiento completo de la lámina \cite{soliman}. 
\begin{figure}[!h]
        \centering
		\includegraphics[width=0.4\textwidth]{Imagenes/imagenes/cap6/limitar_amplitud}  
        \caption{Limitación de amplitud con tope superior.}
        \label{fig:cap6:limita}
\end{figure}
\FloatBarrier

La técnica de osciladores acoplados se basa en un modelo de resorte con masa como ya se había visto y a su vez otro resorte con masa acoplado al primero \cite{acoplados}.
\begin{figure}[!h]
        \centering
		\includegraphics[width=0.4\textwidth]{Imagenes/imagenes/cap6/oscaco}  
        \caption{Osciladores acoplados.}
        \label{fig:cap6:limita}
\end{figure}
\FloatBarrier

Estos dos últimos métodos si bien es cierto que aumentan el ancho de banda, también disminuyen mucho la potencia producida respecto a la situación de trabajo normal.
Puesto que el objeto de este proyecto es diseñar, fabricar y sintonizar un generador, no se va a contemplar la opción de modificar el ancho de banda, delegando la tarea de obtener la máxima energía en la sintonización.


\subsubsection{Sintonización}


La RAE define sintonizar como: Ajustar la frecuencia de resonancia de un circuito a una frecuencia determinada.
En esta caso, el circuito es el generador, en concreto la lámina, que como ya hemos visto tiene una frecuencia de resonancia asociada que varía tanto en función de sus características físicas como de la masa que tenga en su extremo.
Y la frecuencia a la que hay que llegar es la frecuencia de vibración del entorno en el que se encuentre el generador.

\textbf{\underline{Calculo teórico de la frecuencia de resonancia de la lámina.}}
\begin{equation}
f_{r}=\frac{1}{2\pi}\sqrt{\frac{K}{m}}
\label{cap6:equation:fresonancia}
\end{equation}


$f_{r}:$Frecuencia de resonancia.[Hz]

$K:$Constante de amortiguamiento.[N/m]

$m:$ Masa de extremo del resorte.[g]

La constante K puede escribirse como:

$$K=\frac{Ywh^{3}m}{4L^{3}(m+0.24m_{c})}$$

$h:$Grosor de la lámina.

$w:$Anchura de la lámina.

$L:$Largo de la lámina.

$m_{c}:whL\rho$

$\rho:$ Densidad del material de la lámina.

$Y:$Módulo de Young del material de la lámina.
\\
\\
Por lo tanto la ecuación para el cálculo de la frecuencia de resonancia queda:
\begin{equation}
f_{r}=\frac{1}{2\pi}\sqrt{\frac{Ywh^{3}}{4L^{3}(m+0.24m_{c})}} 
\label{cap6:equation:fresonancia2}
\end{equation}

Estudiando esta formula se hallan tres posibles maneras de variar a frecuencia de resonancia:
\begin{itemize}
\item Cambiar el centro de gravedad de la masa del extremo. Parámetro m.
\item Variar la rigidez de la lámina. Parámetro Y.
\item Cambiar las dimensiones físicas de la lámina. Parámetros w, h, y L.
\end{itemize}

\textbf{ \underline{Primer método:}} \textbf{ Modificación del centro de gravedad de la masa del extremo}

\bigskip
De la formula se extrae que actuando sobre el parámetro de masa, se puede modificar la frecuencia de resonancia. La variación se daría en función de $m^{2}$. 

En el caso de este proyecto, la masa en el extremo de la lámina son los imanes del transductor. Pero como ya se ha visto si desplazásemos estos, se perdería el acoplo que tienen con la bobina.
 
\bigskip

Una posible solución sería añadir una masa extra que pueda ser desplazada sin que se pierda acoplo bobina-imanes. Aunque esta solución pueda parecer sencilla, la dificultad de su implementación radica en la forma de desplazar la masa en dos direcciones, puesto que iría montada sobre la lámina que está en constante movimiento.
\bigskip

Por estas dos razones, esta no será la manera elegida para sintonizar el generador.

\begin{figure}[!h]
        \centering
		\includegraphics[width=0.8\textwidth]{Imagenes/imagenes/cap6/masa_extra}  
        \caption{Esquema de como sería el sistema con masa extra.}
        \label{fig:cap6:mextra}
\end{figure}
\FloatBarrier
\bigskip

\textbf{\underline{Segundo método:}} \textbf{ Variación del coeficiente de elasticidad de la lámina}
\bigskip

El segundo parámetro sobre el que se puede actuar según la fórmula dada sería la constante de amortiguamiento de la lámina. 
\bigskip

Puesto que una vez elegida una lámina determinada, su constante de amortiguamiento no puede ser modificada, se han propuesto dos opciones diferentes.
\begin{itemize}
\item Electroimanes.
\item Láminas paralelas.
\end{itemize}

Mediante la técnica de electroimanes se puede conseguir cambiar la elasticidad de una lámina siempre y cuando esta sea ferromagnética. Regulando la atracción de los imanes que actúan sobre la lámina, se puede modificar su constante de amortiguamiento sintonizando el generador. Esta solución sin embargo no es viable ya que se requeriría un uso continuo de energía para mantener los electro-imanes funcionando.
\begin{figure}[!h]
        \centering
		\includegraphics[width=0.8\textwidth]{Imagenes/imagenes/cap6/electro_iman}  
        \caption{Esquema de sintonización con electroimanes.}
        \label{fig:cap6:eliman}
\end{figure}
\FloatBarrier
Este efecto también se puede conseguir con imanes permanentes simplemente variando la distancia de estos a la lámina. Este método a diferencia del anterior no requiere de un gasto continuo de energía para alimentar imanes, sino que lo requeriría para desplazarlos.
\bigskip

La técnica de láminas paralelas se basa en acoplar otras láminas a la principal, de esta manera la constante equivalente es la suma de las constantes de amortiguamiento de las dos. La manera de sintonizar mediante este método es ir desplazando una lamina sobre otra, de tal manera que se el coeficiente de amortiguamiento varíe en función del área compartida por las dos laminas.
\bigskip

Este método requiere de gran precisión en el acoplo, puesto que aunque una de las láminas tiene que ser móvil, tiene que tener una fijación perfecta con la otra para que no haya variaciones indeseadas del coeficiente de amortiguamiento. Por esta causa se considera que este método es de una dificultad técnica considerable y no será empleado.

\begin{figure}[!h]
        \centering
		\includegraphics[width=0.8\textwidth]{Imagenes/imagenes/cap6/lamina_aux}  
        \caption{Esquema de como sería el sistema una lamina extra.}
        \label{fig:cap6:lextra}
\end{figure}
\FloatBarrier


\textbf{\underline{Tercer método:}} \textbf{Variación de los parámetros físicos de la lámina}

Aunque variar el grosor y el ancho de la lámina es impracticable, modificar su longitud si es posible aunque no trivial. Por tanto \textbf{la dimensión a variar será L} (largo de la lámina) que como se ha visto, hace que la frecuencia de resonancia (fr) cambie inversamente proporcional a $L\frac{3}{2}$.  Es decir, disminuyendo L, aumenta Fr.


\begin{figure}[!h]
        \centering
		\includegraphics[width=0.8\textwidth]{Imagenes/imagenes/cap6/sintonizacion_mecanica}  
        \caption{Modificación de la frecuencia de resonancia en función de la longitud.}
        \label{fig:cap6:lextra}
\end{figure}
\FloatBarrier

Ahora queda estudiar la manera óptima de conseguir variar este parámetro.

\underline{Objetivo:}
\bigskip

Variar de forma eficiente la longitud de la lámina.
\bigskip

\underline{Soluciones:}
\bigskip

La  \textbf{primera solución} es inmediata, requeriría soltar la lámina de la base, desplazarla y volver a ajustarla, con el consiguiente gasto de energía y pérdida de eficiencia. \textbf{Este método no es práctico} para un sistema que tiene que sintonizarse de forma autónoma, y por eso será descartado.
\bigskip
 
La \textbf{segunda solución} que se pensó, pasaría por un sistema de engranajes o ruedas dentadas que mediante un motor desplazasen la lamina. Esta solución elimina el problema de soltarla y volver a ajustarla en una nueva posición, sin embargo \textbf{aumenta considerablemente la dificultad de fijarla a la base} y del mecanismo en general por lo que también se descartó.

\begin{figure}[!h]
        \centering
		\includegraphics[width=0.8\textwidth]{Imagenes/imagenes/cap6/dentada}  
        \caption{Lámina dentada con rueda dentada que la desplaza.}
        \label{fig:cap6:lextra}
\end{figure}
\FloatBarrier


Estas soluciones presentadas además conllevan un problema que no se ha mencionado. Como se ha definido anteriormente, la arquitectura del generador requiere de una bobina fija en la base e imanes suspendidos de la lámina. Si se desplazase esta, los imanes se moverían respecto a la bobina perdiendo el máximo de flujo magnético necesario para generar energía.
Para contrarrestar este efecto, se podría pensar en implementar otro mecanismo que moviese la bobina a la vez que la lámina para que siempre estuviesen enfrentados imanes y bobina algo que requeriría una complejidad desmedida que además iría asociada a una pérdida de eficiencia considerable. Este problema nos lleva a la tercera solución donde se implementa la idea de longitud efectiva y el sintonizador.
\bigskip

\textbf{Tercera solución: Variación de la longitud efectiva y sintonizador.}
\bigskip

Una solución basada en la idea de longitud efectiva no requiere el desplazamiento de la lámina, por lo tanto no habría que preocuparse del anclaje de esta a la base, ni del desacoplo de la bobina respecto a los imanes.
Esta idea se basa en la inclusión de un sintonizador, que \textbf{mediante su desplazamiento a lo largo de la lámina va acortando o alargando la longitud \underline{vibrante} de la misma.}

\bigskip

De esta manera la longitud total de la lámina, entendida como distancia de la masa al anclaje, es siempre la misma y solo varia la longitud vibrante, es decir, la sección de lámina que comprende desde los imanes al sintonizador.


Esta solución ofrece una manera sencilla, efectiva y eficiente de sintonizar el sistema.

\begin{figure}[!h]
        \centering
		\includegraphics[width=0.8\textwidth]{Imagenes/imagenes/cap6/long_eff}  
        \caption{Esquema del sistema con sintonizador y longitud efectiva.}
        \label{fig:cap6:lextra}
\end{figure}
\FloatBarrier

De \citep{sintonization} se extrae la siguiente tabla donde se muestran las diferentes manera de maximizar la energía recolectada, ya sea sintonizando o aumentando el ancho de banda:
\begin{figure}[!h]
        \centering
		\includegraphics[width=1\textwidth]{Imagenes/imagenes/cap6/tabla_sintonia}  
        \caption{Maneras de maximizar la extracción de energía.}
        \label{fig:cap6:maneras}
\end{figure}
\FloatBarrier

%-------------------------------------------------------------------
\section{Sintonizador}
%-------------------------------------------------------------------
\label{cap6:sec:sintonizador}
%-------------------------------------------------------------------
De todos estos métodos presentados se va a implementar la sintonización mecánica mediante la variación de la longitud efectiva a cargo de un sintonizador.

\subsection{Objetivo}
Llegados a este punto, el siguiente paso es encontrar una forma de mover el sintonizador a lo largo de la lámina de forma controlada.

\subsection{Mecanismo de movimiento}
La primera opción que se plantea es el uso de micro-motores. Los distintos tipo de motores y actuadores serán discutidos mas adelante. 
El problema que se presenta es que con los micro-motores se consigue producir movimiento, pero este movimiento es circular, hay que encontrar una manera de transformarlo en movimiento lineal.

\subsection{Solución al movimiento circular}
\label{cap6:subsec:sinfin}

Tras barajar varias opciones,  (correa pasadora,  engranajes) la manera que se ha pensado que es mas efectiva es mediante  un tornillo sin fin conectado a la vez al motor y al sintonizador.
De esta manera, mediante el giro del motor, gira el tornillo, y este a su vez, convierte el movimiento circular en lineal al pasar por una tuerca incrustada en el sintonizador.

El tornillo empleado para este proyecto será de métrica 4 con un paso de 0.7mm.
\bigskip

Volviendo a la tabla \ref{fig:cap6:maneras} se aprecia que los métodos de sintonización mecánica, en concreto cambiar las dimensiones, como es el método que aquí se utiliza, no son aplicables mientras el generador esta funcionando, sin embargo mediante la técnica aquí presentada del sintonizador, ese problema desaparece y el generador puede ser sintonizado aun cuando esta activo. Esta es la mejora principal conseguida con este proyecto.
\bigskip

%-------------------------------------------------------------------
\section{Propuesta de algoritmos de funcionamiento}
%-------------------------------------------------------------------
\label{cap6:sec:algoritmos}
%-------------------------------------------------------------------
Para maximizar la generación de energía hace falta implementar un sistema que sea capaz de decidir si la frecuencia de resonancia del sistema coincide con la del entorno y en función de esto tomar las medidas necesarias para sintonizarlo de forma eficiente. El núcleo de este sistema estará formado por un \ac{MCU} PIC de microchip encargado de la ejecución de algoritmo que derivaran en el sintonizado del sistema.

Si antes se ha comentado que lo más importante del proyecto es la sintonización del generador, los encargados de conseguir este objetivo son en gran parte los algoritmos.
\begin{figure}[!h]
        \centering
		\includegraphics[width=0.5\textwidth]{Imagenes/imagenes/cap6/algoritmo_ejemplo}  
        \caption{Algoritmo de ejemplo.}
        \label{fig:cap6:algo_ejem}
\end{figure}
\FloatBarrier

Llegados a este punto hay que diferenciar entre dos conceptos importantes, cada uno asociado a un algoritmo distinto.
\bigskip

\textbf{El primero} de ellos son los algoritmos de captura de señal y su interpretación que darán lugar a la identificación de una situación de sintonización o su opuesta. Serán llamados algoritmos de captura.
\bigskip

\textbf{El segundo} concepto se da una vez identificada una situación de desintonizado. Trata los algoritmos necesarios para maximizar la eficiencia a la hora de buscar la nueva frecuencia de resonancia. Serán llamados algoritmos de sintonización.

En la imagen \ref{fig:cap6:algo_ejem} estos dos conceptos aparecen juntos en un intento de dar una imagen general del sistema.

Los dos conceptos en conjunto son los encargados de que el sistema pueda ser sintonizado de la manera más eficiente posible en base a unos parámetros físicos establecidos (tamaño del generador, amplitud de las vibraciones, variaciones en la frecuencia de las vibraciones). De esta manera distintos algoritmos implementados sobre el mismo sistema darán lugar a distintos resultados. Es objetivo de este proyecto desarrollar y probar los mejores algoritmos posibles dadas las limitaciones sobre las que se implementan, tales como: bajo consumo, limitación de recursos del \ac{MCU} y precisión de los motores.
\bigskip


Para hacer la redacción de este proyecto más legible, se va a separar la definición e implementación de los dos tipos de algoritmos antes mencionados. En este apartado se estudiara la definición y en un apartado posterior \ref{cap6:subsubsec:implementacion} se estudiará la implementación.








\subsection{Algoritmos de captura:}
\label{cap6:subsec:propone_captura}
Aquí se exponen los modos que se han propuesto para detectar una situación de desintonzado lo mas eficientemente posible. Pero lo primero es decidir donde se va a medir la energía producida.
\subsubsection{Medida de la señal producida}
El generador sintonizado produce una tensión que puede ser fácilmente medida, de esta manera, se puede identificar una situación de desintonizado mediante la detección de la caída en la tensión que está generando.  Este método es trivial puesto que por la alta Q que presentan estos generadores, una mínima desviación en la frecuencia de vibración, produciría una súbita caída en la tensión generada.
Por otro lado hay dos puntos de donde se puede extraer y medir esta señal. El primero es a la salida de la bobina (figura \ref{fig:cap5:villardin}) y el segundo es a la salida del multiplicador de Villard (figura \ref{fig:cap5:villardout}).
\bigskip

\underline{Salida de la bobina:} Como se ve en la figura \ref{fig:cap5:villardin}, en este punto la señal , alterna centrada en 0, presenta dificultades para su captura por dos razones:
\bigskip

La frecuencia de esta señal, es la frecuencia de resonancia del generador y por lo tanto variable. De esta manera es difícil sabe que tipo de señal (periodo) se espera medir en cada momento.

\bigskip

El otro motivo es el poco nivel de tensión que presenta.

Estas dos razones hacen que medir en este punto con un \ac{MCU} sea mas difícil que la otra alternativa.
\bigskip

\underline{Salida del multiplicador:} En este punto hay un nivel de tensión continua comparable a los valores de funcionamiento del \ac{MCU} y por lo tanto es más adecuado para tomar las medidas sin embargo el uso de condensadores provoca que la caída de la señal, cuando el generador se desintoniza, no sea inmediata, lo que provoca problemas para detectar con rapidez esta situación.

\bigskip

En la sección \ref{cap6:subsubsec:implementacion} se proponen modos de implementar ambas opciones con un \ac{MCU} real.

\subsubsection{Algoritmo de captura 1: Medidas periódicas.}
Desarrollando el algoritmo de ejemplo para darle un sentido real, se obtiene una primera aproximación que puede ser implementada.

\begin{figure}[!h]
        \centering
		\includegraphics[width=0.5\textwidth]{Imagenes/imagenes/cap6/algoritmo_simple}  
        \caption{Algoritmo simple implementable.}
        \label{fig:cap6:algo_simple}
\end{figure}
\FloatBarrier

Este algoritmo permite tiempos en los que el \ac{MCU} esta dormido y por lo tanto no está consumiendo. Sin embargo si este tiempo es muy grande puede ser que, para cuando se mida la energía que se esta produciendo, el generador lleve tiempo desintonizado.
Esta filosofía es óptima cuando el sistema pasa poco tiempo sintonizado y los cambios en la frecuencia del medio son frecuentes.
\bigskip

\textbf{Ventajas:} Bajo consumo y facilidad de implementación.
\bigskip

\textbf{Desventajas:} Poca capacidad de reacción ante cambios en la frecuencia de vibración.
\subsubsection{Algoritmo de captura 2: Basado en interrupciones.}
En situación de sintonización el \ac{MCU} está dormido. Cuando se detecta una caída en la entrada, se dispara una interrupción que le despierta para que inicie una rutina de sintonizado. Mientras esta desintonizado el \ac{MCU} no se duerme hasta que encuentra la posición de sintonizado.

De esta manera no hay que realizar medidas periódicas, lo que deriva en un mayor ahorro de energía.
\bigskip
 
Cuando salta la interrupción hay dos formas de proceder:

La primera sería realizar una medida para comprobar que realmente la tensión a la entrada ha caído y no se trata de una falsa alarma, y la segunda sería llamar directamente al algoritmo de sintonizado.
Esta filosofía es óptima cuando el sistema está la mayor parte del tiempo sintonizado.
\bigskip

\textbf{Ventajas:} Máximo ahorro de energía y alta velocidad de reacción ante una caída en la entrada.
\bigskip

\textbf{Desventajas:} Mayor complejidad en la programación.


\subsection{Algoritmos de sintonización:}
\label{cap6:subsec:propone_sinto}
Una vez que se sabe que el sistema no trabaja a la frecuencia del entorno hay que lanzar los algoritmos de sintonizado para reajustar la frecuencia de resonancia.

Estos algoritmos no son más que la manera de mover el sintonizador para conseguir la sintonización en el menor tiempo posible y con el menor gasto de energía posible.

Dado que el generador presenta una alta \ac{Q} y suponiendo un desconocimiento de los comportamientos del entorno, (frecuencias de resonancias mas frecuentes) la única forma de encontrar la nueva frecuencia de resonancia es mediante un barrido a lo largo de la lámina. 
\bigskip

Si se conociesen las frecuencias mas usuales del entorno, se podría implementar un sistema predictivo para buscar primero en esas frecuencias. Esto es posible mediante la implementación del sistema antes mencionado, para que el \ac{MCU} conozca en todo momento la frecuencia a la que esta trabajando el generador en función de la posición del sintonizador y sea capaz de calcular el desplazamiento necesario de este para fijar una determinada frecuencia.
\bigskip

Por lo tanto se va a trabajar sobre dos tipos de algoritmos.


\subsubsection{Algoritmos no predictivos: }

Son los algoritmos en los que el controlador no conoce la frecuencia a la que se esta trabajando y simplemente realiza un barrido en toda la lámina buscando la frecuencia de resonancia.
Se ha pensado en dos algoritmos.
\bigskip

\textbf{\underline{Barrido lineal:}}

Empieza a mover el sintonizador desde la ultima posición de sintonización hasta llegar a un extremo. Si llega a ese extremo y no ha encontrado la nueva frecuencia de resonancia, vuelve hasta la posición inicial y realiza el barrido hacia el otro sentido.
\begin{figure}[!h]
        \centering
		\includegraphics[width=0.8\textwidth]{Imagenes/imagenes/cap6/algoritmo_lineal}  
        \caption{Algoritmo de barrido lineal.}
        \label{fig:cap6:algo_lineal}
\end{figure}
\FloatBarrier

Este algoritmo es el mas inmediato, es sencillo de implementar y no requiere muchos recursos del \ac{MCU}. La parte negativa es que en determinadas circunstancias el tiempo de sintonizado es muy grande, esto se da por ejemplo si la nueva frecuencia de resonancia se desplaza hacia el sentido opuesto al que el \ac{MCU} empieza a barrer. Si esto pasa, para encontrar la nueva situación de sintonización, el sintonizador primeramente tendrá que recorrer todo un lado de la lamina, para recorrer posteriormente la zona donde se halla el objetivo.
\bigskip

\textbf{Ventajas:}
Facilidad en la implementación.

\textbf{Desventajas:}
Tiempos de sintonizado grandes si la frecuencia del entorno se desplaza hacia el sentido opuesto.
\bigskip

\textbf{\underline{Barrido Alternante:}}
\label{cap6:subsec:altern}
Este algoritmo ha sido desarrollado para suplir las deficiencias en la busqueda que presenta el algoritmo anterior como se puede ver en la imagen \ref{fig:cap6:algo_lineal_mal}.

\begin{figure}[!h]
        \centering
		\includegraphics[width=0.8\textwidth]{Imagenes/imagenes/cap6/algoritmo_lineal_mal}  
        \caption{Desventaja del algoritmo de barrido lineal.}
        \label{fig:cap6:algo_lineal_mal}
\end{figure}
\FloatBarrier


Por esto el nuevo algoritmo propuesto alterna las posiciones de medida. Realiza una medida a cada lado de la posición de sintonización incrementado en cada iteración una posición.
\bigskip

El funcionamiento es el siguiente:
\bigskip

Cuando detecte una situación de desintonizado, el sintonizador se moverá un paso hacia un sentido de búsqueda. Si no ha encontrado la situación de sintonizado, se desplazará dos posiciones hacia el otro sentido. Si aun no este sintonizado, se desplazará tres posiciones hacia el sentido inicial, y así sucesivamente, alternándose entre frecuencias cada vez mayores y menores (posiciones a un lado y el otro de la posición inicial)respecto de la frecuencia inicial.
\bigskip

 En la siguiente figura se puede ver un esquema del funcionamiento de este algoritmo.
\begin{figure}[!h]
        \centering
		\includegraphics[width=0.8\textwidth]{Imagenes/imagenes/cap6/algoritmo_alter}  
        \caption{Funcionamiento del algoritmo alternante.}
        \label{fig:cap6:algo_alter}
\end{figure}
\FloatBarrier

Este algoritmo es muy eficiente en el caso de que la frecuencia se haya desplazado poco entorno a la anterior situación de sintonizado.
\bigskip

\textbf{Ventajas:}
Poco tiempo y por lo tanto mas eficiencia en la búsqueda de frecuencias cercanas a la inicial.

\textbf{Desventajas:}
Si la nueva frecuencia del entorno esta muy separada del la inicial, llevaría mucho tiempo volver a sintonizar el generador. Este problema también lo presenta el algoritmo lineal. 

Para intentar minimizar el efecto producido por grandes diferencias en las frecuencias, hay dos opciones:

\begin{enumerate}
\item Suponer que las variaciones de frecuencia serán pequeñas, por lo que el algoritmo alternante seria el adecuado.

\item Implementación de algoritmos predictivos. 
\end{enumerate}


\subsubsection{Algoritmos predictivos:}
En estos, el \ac{MCU} conoce la frecuencia de resonancia (frecuencia de trabajo actual del generador) y es capaz de relacionarla con los cambios en la posición del sintonizador.

Con esta funcionalidad implementada, habría que establecer unas condiciones iniciales, ya sea con sensores fin de carrera o manualmente, para que al iniciarse pueda ser calibrado indicándole la frecuencia de resonancia de ese punto.
\begin{figure}[!h]
        \centering
		\includegraphics[width=0.8\textwidth]{Imagenes/imagenes/cap6/predictivo}  
        \caption{Funcionamiento del algoritmo predictivo.}
        \label{fig:cap6:predictivo}
\end{figure}
\FloatBarrier

Además para aumentar la eficiencia, hay que caracterizar previamente el entorno. Encontrar las frecuencias que más se repiten y con qué asiduidad para asignarles probabilidades.

De esta manera si se detecta una desintonización el \ac{MCU} desplazaría el sintonizador a la siguiente frecuencia con más probabilidad, y así sucesivamente hasta volver a estar sintonizado.

Estos algoritmos son más eficientes que los no predictivos, sin embargo presentan mayor dificultad de implementación y requieren calibración periódica puesto que si se desvían sus parámetros iniciales, no conseguiría volver a sintonizarse.
\bigskip

\textbf{Ventajas:}
Si el entorno tiene un conjunto pequeño de frecuencias características que se repiten con bastante probabilidad, es posible desplazar primero a esos punto el sintonizador, ahorrando barridos completos que es lo que gasta mas tiempo y energía.

\textbf{Desventajas:}
Si las ventajas de estos algoritmos son importantes, también es cierto que tiene importantes desventajas.

Dificultad de implementación.

Calibración periódica.

Electrónica extra en el generador (sensores fin de carrera).

Si la nueva frecuencia no coincide con ninguna de las características, hay que lanzar un algoritmo de barrido, lo que lo convertiría en el algoritmo mas costoso.

%-------------------------------------------------------------------
\section{Electrónica implementada}
%-------------------------------------------------------------------
\label{cap6:sec:electronica}
%-------------------------------------------------------------------
En esta sección se detalla la electrónica implementada y como se ha diseñado para que cumpla la función requerida, que es la de sintonizar el generador. 
\medskip

La electrónica tiene que:
\begin{enumerate}
\item Medir energía producida.
\item interpretar si es necesaria una sintonización.
\item En caso afirmativo tiene que actuar sobre un motor para desplazar el sintonizador.
\end{enumerate} 


En este capítulo se tratará:
\begin{itemize}
\item El estudio de los motores disponibles y sus ventajas/desventajas para su uso en este proyecto.
\item El estudio de los \ac{MCU} disponibles y en detalle el elegido.
\item El estudio de la electrónica adicional necesaria, como circuitos integrados
\end{itemize} 


\subsection{Motores}
\label{cap6:subsec:motor}
Llegados a este punto, ya esta diseñado el sintonizador, pero resta implementar el medio físico que lo desplace. El actuador más lógico seria un motor eléctrico y dado que se está generando una tensión continua, un motor eléctrico de corriente continua.


Para elegir el motor idóneo hay que tener en cuenta varias características.

\begin{itemize}
\item Consumo
\item Tamaño
\item Par
\item Velocidad
\end{itemize}

Con estas características en cuenta se pasa a realizar un estudio de los tipos de motores disponibles:
Cada vuelta del motor y por lo tanto de la varilla corresponde a 1mm.
El problema que aquí se presenta es estimar cuanto va a haber que mover el sintonizador para volver a sintonizar. Dado que el motor se va a alimentar de la propia generación nos interesa que sea de corriente continua y que haya que desplazar poco el sintonizador para volver a la frecuencia de resonancia. Aquí surgen varias opciones de motores:

\subsubsection{Motores de corriente continua}
Lo motores de corriente continua se pueden dividir en dos tipos. Con escobillas \cite{motor1} y sin ellas \cite{motor2}.
 
\textbf{\underline{Con escobillas:}}

Son motores muy sencillos de usar y gracias al modo PWM (modulación por anchura de pulso) se puede regular su velocidad. Constan de un sistema mecánico (escobillas) para controlar la posición en cada momento y excitar las bobinas en el instante preciso para hacer que el motor siga girando. En estos motores, las bobinas están sobre el rotor y los imanes permanentes en el estator.  La principal desventaja es que las escobillas generan rozamiento lo que conlleva perdida de eficiencia además de arcos eléctricos, produciendo ruido que puede interferir en sistemas cercanos.

Para desplazar distancias cortas (algoritmo alternante: ver sección \ref{cap6:subsec:altern}) nos interesa que sea de poca velocidad para tener mejor precisión. Esto se consigue con motores de continua con reductora que además de ofrecer poca velocidad, producen un par mayor.
Por otra parte la dificultad que presentan es que necesitan un puente H para poder invertir el giro.
\bigskip

\textbf{Conclusión:} Motores aptos para el proyecto.
\bigskip

\textbf{\underline{Motores sin escobillas o BLDC:}}

Son motores de 3 hilos, con una alta eficiencia a altas revoluciones, pero con una mayor dificultad de manejo. Como no tienen un sistema mecánico de escobillas para determinar su posición, su sincronización se hace más compleja. Se necesita un \ac{MCU} junto con dos estrategias para determinar en cada momento la situación del rotor y en función de ella excitar una bobina u otra: sensores de efecto Hall y cálculo mediante el efecto de fuerza contra-electromotriz (back EMF).
\bigskip

\textit{Efecto Hall:} En un conductor por el que circula corriente, en presencia de un campo magnético perpendicular al movimiento de las cargas, aparece un campo eléctrico transversal a este movimiento. 

Gracias a este efecto se pueden integrar sensores en el motor que determinen el estado en cada momento del rotor en función de los campos magnéticos inducidos. De esta forma y mediante realimentación, el controlador puede sincronizar las señales de excitación.
\bigskip

\textit{Fuerza contra-electromotriz:} Este método se basa en medir la fuerza electromotriz inducida en la bobina que no está excitada en un momento dado debido al movimiento del rotor y de las otras dos bobinas. Por la ley de Lentz, la fuerza electromotriz se opone a la fuerza que la produce (motor en movimiento) y mediante esta medida se puede conocer el estado del motor y en función de él sincronizar las señales de excitación.
\bigskip


La dificultad para el uso de estos motores requiere de una gran electrónica lo que incrementaría el consumo, el coste y el tamaño total ocupado por el motor.

Por otra parte, los métodos de sincronismo vistos solo funcionan correctamente cuando el motor trabaja a alta velocidad haciéndolos inservibles para este proyecto puesto que esto provoca un consumo elevado.
\bigskip

\textbf{Conclusión:} Motores descartados para este proyecto.

\subsubsection{Motores paso a paso}

Pueden considerarse un tipo de motores BLDC sin embargo su modo de empleo es totalmente distinto.

Se componen de 2 bobinas en diferentes posiciones, y mediante una serie de excitación de las distintas bobinas, el motor se mueve una serie de posiciones discretas.

Este tipo de motores se divide a su vez en dos tipos, unipolares y bipolares y lo que los diferencia es la manera de usar las dos bobinas.

\bigskip

\textbf{\underline{Unipolar:}}

La única diferencia con los motores bipolares es que a la mitad de la bobina hay una conexión denominada común. Esta se conecta a una fuente de tensión y mediante la conmutación a masa en los otros dos extremos de la bobina, se generan campos que atraen el imán. Por lo tanto estos motores pueden tener 5 o 6 cables dependiendo si los terminales "común" esta unidos internamente o no.

La ventaja de estos motores es su sencillez de manejo. La desventaja es que producen poco par.
\begin{figure}[!h]
        \centering
		\includegraphics[width=0.5\textwidth]{Imagenes/imagenes/cap6/unipolar}  
        \caption{Esquema de un motor unipolar.}
        \label{fig:cap6:unipolar}
\end{figure}
\FloatBarrier

\textbf{Conclusión:} Motor apto para el proyecto.
\bigskip

\textbf{\underline{Bipolar:}} 

Dado que solo tiene 4 conexiones, la única manera de invertir la polaridad de una bobina es invirtiendo el sentido de la corriente que circula por ella. Esto se consigue con un puente H para cada bobina, por lo tanto para excitar este tipo de motores hace falta un circuito que integre dos puentes H. La ventaja de estos motores es que generan mas par que los unipolares pero a costa de una dificultad mayor en el manejo.
\begin{figure}[!h]
        \centering
		\includegraphics[width=0.5\textwidth]{Imagenes/imagenes/cap6/bipolar}  
        \caption{Esquema de un motor bipolar.}
        \label{fig:cap6:bipolar}
\end{figure}
\FloatBarrier
\textbf{Conclusión:} Motor apto para el proyecto.
\bigskip

Dado que los motores paso a paso se usan excitando una bobina cada vez, el consumo se reduce.
\bigskip

\begin{table}[!hbt]
\begin{center}
\begin{tabular}{||l | c | c | c | r||}
\hline
\hline
Tipo de motor & Consumo & Tamaño & Par &¿Es adecuado?\\
\hline
C. Continua & No & Si & Si & Si\\
\hline
BLDC & No & No & Si & No\\
\hline
Unipolar & Si & Si & No & Si\\
\hline
Bipolar & Si & Si & Si & Si\\
\hline

\end{tabular}
\caption{Tabla comparativa de motores.}
\label{tab:cap4:motores aptos}
\end{center}
\end{table}

\subsubsection{Motores adquiridos}
\label{cap6:subsubsec:disponibles}
Tras una búsqueda de los motores mas apropiados se han seleccionado los siguientes para las pruebas:

\textbf{\underline{Motores de corriente continua:}}

Para estos motores se ha recurrido al fabricante Precision Microdrivers \cite{precisionmicro}.

En concreto se han adquirido los siguientes motores:
\begin{table}[!hbt]
\begin{center}
\begin{tabular}{||l | c | c||}
\hline
\hline
Motor & Consumo (V)& R.P.M  \\
\hline
210-002 & 2.5 & 58\\
\hline
212-008 & 2.5 & 42\\
\hline
206-108 & 3 & 28\\
\hline
206-109 & 3 & 140\\
\hline
212-108 & 5 & 42\\
\hline
\end{tabular}
\caption{Motores comprados en \cite{precisionmicro}.}
\label{tab:cap4:motores aptos}
\end{center}
\end{table}

Las características de estos motores se pueden consultar en el anexo [PONER EL ANEXO DONDE LAS DATASHEETS DE LOS MOTORES]
\bigskip

\textbf{\underline{Motor paso a paso unipolar:}}

Unipolar de 6 hilos ( el común de las dos bobinas esta separado) y 3Vdc.
\bigskip

\textbf{\underline{Motor paso a paso bipolar:}}
Bipolar de 4 hilos de Cannon. 3Vdc.

Diámetro del eje: 1,5mm.

Tamaño: 7mmX6mm.
%-------------------------------------------------------------------
\subsection{Circuitos integrados controladores de motores}
%-------------------------------------------------------------------
\label{cap6:sec:integrados}
%-------------------------------------------------------------------

Dado que los distintos tipos de motores que se van a emplear (c. continua, unipolares y bipolares)  necesitan distintos circuitos controladores hay que buscar distintos integrados que nos proporcionen estas funciones.

La mayoría de estos circuitos se compone de puentes H.

\begin{figure}[!h]
        \centering
		\includegraphics[width=0.7\textwidth]{Imagenes/imagenes/cap6/hbridge}  
        \caption{Puente H.}
        \label{fig:cap6:puenteH}
\end{figure}
\FloatBarrier

El puente H de la imagen \ref{fig:cap6:puenteH} es un circuito simplificado implementado con interruptores pero se ve la idea claramente. 

\begin{itemize}
\item Si B1 y B2 están abiertos y A1 y A2 cerrados (izquierda), el motor gira en un sentido. 
\item Si B1 y B2 están cerrados y A1 y A2 abiertos (derecha), el motor gira en el otro sentido.
\item Si A1 y B2 están abiertos, el motor gira libremente.
\item Si A1 y B2 están cerrados, el motor esta bloqueado y no se puede mover.
\end{itemize}

Los puentes H que integran los circuitos que se van a emplear están construidos con transistores como se ve en \ref{fig:cap6:puenteH2}.

\begin{figure}[!h]
        \centering
		\includegraphics[width=0.5\textwidth]{Imagenes/imagenes/cap6/hbridge2}  
        \caption{Puente H de transistores.}
        \label{fig:cap6:puenteH2}
\end{figure}
\FloatBarrier

\subsubsection{Controlador de motores de continua}

Estos motores por su construcción, necesitan un puente H para controlar el sentido de giro puesto que cuentan con una sola bobina, y según el sentido de circulación de la corriente por ella, varía el sentido de giro del motor.

\subsubsection{Controlador de motores unipolares}

Según se ve en la figura \ref{fig:cap6:unipolar} el funcionamiento de estos motores no se realiza mediante un puente H.

Se conecta el común a una fuente de tensión, y se conmutan los restantes 4 extremos de las bobinas a tierra secuencialmente para que se desplace paso a paso.

Esta función se realiza mediante un circuito encoder que conecte los extremos de las bobinas a tierra.

\subsubsection{Controlador de motores Bipolares}

Puesto que estos motores no tienen terminal común no se pueden usar como los unipolares. Es necesario invertir la corriente por las bobinas con puentes H. Puesto que están formados por dos bobinas, serán necesarios dos puentes H.

\subsubsection{Controlador DRV8833}
\label{cap6:subsubsec:drv8833}
Este circuito es un driver que tiene internamente dos puentes H por lo que se puede emplear tanto para mover un motor de continua (usando solamente uno de los puentes) como un bipolar.



\begin{figure}[!h]
        \centering
		\includegraphics[width=0.7\textwidth]{Imagenes/imagenes/cap6/8833}  
        \caption{Diagrama interno del DRV8833.}
        \label{fig:cap6:8833}
\end{figure}
\FloatBarrier

Tiene 4 entradas digitales (AIN1, AIN2, BIN1 y BIN2). AIN1 y AIN2 controlan un puente H y BIN1 y BIN2 controlan el otro puente.

Tiene una quinta entrada que es la señal de $\overline{sleep}$. La usaremos para apagar el driver cuando no se este usando y reducir el consumo.
\bigskip

\textbf{\underline{Conclusión:}}

Este integrado será usado tanto para los motores de corriente continua como para los paso a paso bipolares.



\subsubsection{Controlador ULN2003A}

Es un array de transistores Darlington. Según se estimule la entrada, conecta una u otra de sus salidas a tierra, convirtiendo este pin en un sumidero de corriente. Este funcionamiento es lo que buscábamos para poder usar un motor paso a paso unipolar.


\begin{figure}[!h]
        \centering
        \subfloat[Diagrama lógico del ULN2003.]{\label{fig:cap4:2003a}\includegraphics[width=0.5\textwidth]{Imagenes/imagenes/cap6/20032}} 
        \qquad
		\subfloat[Uno de los 7 pares Darlington.]{\label{fig:cap4:2003b}\includegraphics[width=0.5\textwidth]{Imagenes/imagenes/cap6/2003}}
\caption{ULN2003.}
        \label{fig:cap4:2003}
\end{figure}
\FloatBarrier

Para usar un motor unipolar con este integrado solo necesitamos los 4 primeros pares Darlington. Cada uno conectado a un extremo de bobina.

\begin{figure}[!h]
        \centering
		\includegraphics[width=0.7\textwidth]{Imagenes/imagenes/cap6/uln2003}  
        \caption{Conexión del motor unipolar.}
        \label{fig:cap6:2003uni}
\end{figure}
\FloatBarrier



\textbf{\underline{Conclusión:}}

Este integrado será usado para los motores paso a paso unipolares.
%-------------------------------------------------------------------
\subsection{Micro controlador o MCU}
%-------------------------------------------------------------------
\label{cap6:sec:micro}
%-------------------------------------------------------------------

La inteligencia del sistema va a residir en el \ac{MCU}. Va ser el encargado de ejecutar los algoritmos propuestos.

Siguiendo la línea del bajo consumo que se quiere alcanzar, este \ac{MCU} tiene que tener unas características tales que maximicen su utilidad y minimicen el consumo.

Su funcionamiento básico será como sigue:
\begin{itemize}
\item Mide la energía que se está produciendo en cada momento.
\item Comprueba si es máxima, (generador sintonizado) o no.
\item Si no está sintonizado ejecuta el algoritmo encargado de colocar el sintonizador en la posición de máxima producción de energía
\end{itemize}
A continuación se va a realizar un estudio de los \ac{MCU} disponibles y su idoneidad para este proyecto:

%\subsection{Estudio de micro-controladores}
\bigskip

El primer paso es dimensionar el \ac{MCU}, estimar la potencia de calculo, el consumo y el número de pines de entrada/salida necesarios para el proyecto. 
\bigskip

En cuanto la potencia de calculo, dado los algoritmos simples que se han propuesto, no va ser necesario que sea muy elevada y puesto que el proyecto se basa en la generación de energía, se buscará un \ac{MCU} de bajo consumo.
\bigskip

Dado el uso tan específico que se va a hacer de estos controladores, y siguiendo el camino del bajo consumo, como primera decisión en esta parte del proyecto se opta por la familia de PICs de 8 bits de Microchip\textregistered.

La mayoría de controladores de esta familia disponen de ADC, comparadores, señales PWM y distinto numero de pines digitales de entrada/salida, lo que va a ser suficiente para el control del dispositivo.

Los controladores que encontramos aquí van desde el PIC 10, el mas bajo de la gama hasta el PIC 16.



\subsubsection{PIC 10LF320}

El primer \ac{MCU} que se estudia es el PIC 10LF320. 
\bigskip

Este \ac{MCU} tiene un consumo mínimo: 25$\mu$A alimentado a 1,8V.

Su frecuencia de funcionamiento es de 16MHz lo que da la suficiente capacidad de calculo para poder implementar los algoritmos propuestos.
\bigskip

\underline{Problema de memoria}
Sin embargo se ha detectado que la memoria de programa es muy limitada (512 palabras), llenándose casi por completo con el algoritmo más básico lo que ha sido suficiente para causar su descarte y el paso a un \ac{MCU} con mas memoria.

\textbf{\underline{Conclusión del estudio:}}
\bigskip

Aunque el \ac{MCU} cumple con las especificaciones de potencia y consumo, su \textbf{limitada memoria de programa} hace que se busque el siguiente \ac{MCU} en la serie PIC 12 donde se puede encontrar uno con la suficiente memoria.

\subsubsection{PIC 12LF1571}

Los \ac{MCU} de la serie PIC 12 tienen mas memoria y su consumo aumenta ligeramente.

En busca del objetivo de conseguir más memoria se ha seleccionado el PIC 12LF1571 con casi 2000 palabras en la memoria de programa, cuyo consumo es 30$\mu$A a 1,8V.

La memoria de programa es en este caso es 4 veces mas que en el caso anterior.

Se han vuelto a cargar varios algoritmos y se ha comprobado que este espacio es suficiente incluso si se quisiese aumentar el tamaño del programa, por lo tanto se ha alcanzado el objetivo del tamaño de la memoria.
\bigskip

\underline{Problema de pines I/O}

Llegados a este punto hay que tomar una decisión en cuanto al numero de pines de entrada/salida necesarios. Este \ac{MCU} dispone de 5 pines, hay que ver si son suficientes o es necesario buscar un \ac{MCU} con más.
\bigskip

Como se ha visto en \ref{cap6:subsubsec:drv8833}, ya solo el integrado DRV8833 necesita 5 pines para su funcionamiento lo que nos dejaría sin pines de entrada en el \ac{MCU} para hacer las capturas de energía producida por el generador.

Aunque en un caso de producto final la solución podría ser tan fácil como multiplexar un pin en el tiempo (para hacer medidas y para mover el motor), esto es un proyecto didáctico, y se ha decidido buscar un \ac{MCU} con mas pines, para que se puedan incorporar mas funcionalidades en un futuro y sea mas fácil la depuración del código de los algoritmos.

\textbf{\underline{Conclusión del estudio:}}
\bigskip

Aunque este \ac{MCU} es valido para el proyecto, en aras de conseguir un sistema más didáctico, se va a buscar un \ac{MCU} con mas pines de entrada/salida para aumentar la flexibilidad de la solución final. El siguiente paso lógico, por tanto, será ir a la serie PIC 16, con mas pines que la serie PIC 12.

\subsubsection{PIC 16LF1503}

Se ha llegado a este \ac{MCU} en la búsqueda de uno con mas pines que el PIC 12LF1571.

Este en concreto dispone de 11 pines de entrada/salida lo que proporciona una flexibilidad mayor que teniendo los pines limitados.


Su consumo es el mismo que el del PIC 12, 30$\mu$A a 1,8V y la frecuencia de trabajo se mantiene a 16MHz.

La memoria de programa es de 2048 palabras y la RAM es de 735 bytes, siendo de los tres vistos, es que mejor características presenta.

\begin{table}[!hbt]
\begin{center}
\begin{tabular}{||l | c | c | c||}
\hline
\hline
Micro-controlador & Consumo ($\mu$A @1.8V) & Pines I/O &  Memoria flash (palabras)\\
\hline
PIC 10LF320 & 25 & 3  &512\\
\hline
PIC 12LF1571 & 30 & 5  &2000\\
\hline
PIC 16LF1503 & 30 & 11  &2048\\
\hline

\end{tabular}
\caption{Comparación de Micro-controladores.}
\label{tab:cap4:micros}
\end{center}
\end{table}



\section{Implementación de los algoritmos de funcionamiento}

\label{cap6:subsubsec:implementacion}
En el apartado \ref{cap6:subsec:propone_captura} se propusieron los métodos de monitorización de la energía producida para detectar un cambio en la frecuencia del entorno y actuar en consecuencia, pero será en esta sección donde se expondrá como se han implementado y programado en el \ac{MCU}.
\bigskip



\subsection{Algoritmos de captura:}
\bigskip

La primera funcionalidad que hay que implementar es la captura de la señal de entrada para saber si el generador esta sintonizado. Como ya se ha expuesto esta señal puede obtenerse de dos puntos.
Directamente de la salida de la bobina o a la salida del multiplicador.
\bigskip

\subsubsection{Medida a la salida de la bobina:}

La señal en este punto es de la forma mostrada en la figura \ref{fig:cap5:villardin}.
\bigskip

En este caso y suponiendo que el nivel de tensión de pico fuese suficiente para ser detectado por el PIC,  bastaría implementar un modo de captura para que cuando detecte una caída de ese nivel, lo interprete como una desintonización. \textbf{Sin embargo, en cada periodo habrá una caída por lo que detectaría des-sintonizaciones falsas.}
\bigskip


Este problema se soluciona mediante la inclusión del concepto de frecuencia. Sabiendo la frecuencia de la señal producida, se puede implementar una captura que detecte desintonización cuando la caída de tensión dure mas de un periodo. Pero por la misma razón por la que no se podían adaptar impedancias siempre en \ref{cap5:sec:adaptacion}, este método aquí no es implementable de forma inmediata dado que \textbf{la frecuencia de trabajo no es única, cambia con cada nueva sintonización.}
\bigskip
\begin{center}


\begin{tikzpicture}[domain=0:10]
    %\draw[very thin,color=gray] (-0.1,-1.1) grid (10,3);
    \draw[very thin,color=gray] (-0.1,0)--(10,0);
    \draw[very thin,color=gray] (-0.1,-1.1)--(-0.1,2);
    %\draw[->] (-0.2,0) -- (4.2,0) node[right] {$x$};
    %\draw[->] (0,-1.2) -- (0,4.2) node[above] {$f(x)$};
    %\draw[color=red] (3,0) to[-|-] (4,1);
    \draw (1.5,-1) node(a) [right] {}  (1.5,1.5) node(b) [above] {Detección de señal};
    \draw [color=green, line width=2pt] (a.south) |- (b.south);
    \draw (4.8,-1) node(c) [right] {}  (4.8,1.5) node(d) [right] {Perdida de señal};
    \draw [color=green, line width=2pt] (c.south) |- (d.south);
  %\draw[color=red] (a.east) -| (2,1.5) -| (b.north);
    \draw[color=red]    plot (\x,0.7)    node[right] {$Umbral$};
    \draw[color=blue]   plot (\x,{sin(\x r)})   node[right] {};
   % \draw[color=orange] plot (\x,{0.05*exp(\x)}) node[right]
       % {$f(x) = \frac{1}{20} \mathrm e^x$};
\end{tikzpicture}
\end{center}

La solución de este nuevo problema es como sigue:

Mediante la inclusión en el programa de la formula de la frecuencia de resonancia (\ref{cap6:equation:fresonancia}) y estableciendo una relación entre el tiempo de giro del motor y la distancia que se mueve el sintonizador, el \ac{MCU} puede estimar en todo momento a que frecuencia esta trabajando el sistema y en función de ella calcular el periodo de la señal que tiene que medir. Es un pseudo-muestreo en que se mide una vez por periodo, pero con unos ciertos márgenes de tolerancia.


Sería además necesaria una inicialización siempre en la misma posición para fijar la frecuencia inicial para que el \ac{MCU} supiese a partir de donde tiene que empezar a trabajar.
\bigskip

Por tanto el proceso quedaría así:
\begin{enumerate}
\item Mediante la fórmula de la frecuencia de resonancia estimar a que frecuencia se esta trabajando.
\item Detectar si la señal medida supera un cierto umbral prefijado.

\begin{tikzpicture}[domain=0:4]
    %\draw[very thin,color=gray] (-0.1,-1.1) grid (10,3);
    \draw[very thin,color=gray] (-0.1,0)--(4,0);
    \draw[very thin,color=gray] (-0.1,-1.1)--(-0.1,2);
    %\draw[->] (-0.2,0) -- (4.2,0) node[right] {$x$};
    %\draw[->] (0,-1.2) -- (0,4.2) node[above] {$f(x)$};
    %\draw[color=red] (3,0) to[-|-] (4,1);
    \draw (1.5,-1) node(a) [right] {}  (1.5,1.5) node(b) [above] {Detección de señal};
    \draw [color=green, line width=2pt] (a.south) |- (b.south);
    %\draw (4.8,-1) node(c) [right] {}  (4.8,1.5) node(d) [right] {Perdida de señal};
    %\draw [color=green, line width=2pt] (c.south) |- (d.south);
  %\draw[color=red] (a.east) -| (2,1.5) -| (b.north);
    \draw[color=red]    plot (\x,0.7)    node[right] {$Umbral$};
    \draw[color=blue]   plot (\x,{sin(\x r)})   node[right] {};
   % \draw[color=orange] plot (\x,{0.05*exp(\x)}) node[right]
       % {$f(x) = \frac{1}{20} \mathrm e^x$};
\end{tikzpicture}

\item Volver a medir y ver si en un tiempo cercano a un periodo (zona [1]), la señal vuelve a superar el umbral

\begin{center}
\begin{tikzpicture}[domain=0:10]
    %\draw[very thin,color=gray] (0,-1) grid (10,2);
    \draw[very thin,color=gray] (-0.1,0)--(10,0);
    \draw[very thin,color=gray] (-0.1,-1.1)--(-0.1,2);
    %\draw[->] (-0.2,0) -- (4.2,0) node[right] {$x$};
    %\draw[->] (0,-1.2) -- (0,4.2) node[above] {$f(x)$};
    %\draw[color=red] (3,0) to[-|-] (4,1);
    \draw (1.5,0) node(a) [right] {}  (1.5,1.5) node(b) [above] {Detección de señal};
    \draw [color=green, line width=2pt] (a.south) |- (b.south);
    
  %\draw[color=red] (a.east) -| (2,1.5) -| (b.north);
    \draw[color=red]    plot (\x,0.7)    node[right] {$Umbral$};
    %\fill[fill=red] (pi/4,0) -- plot [domain=pi/4:3*pi/4] (\x,{sin(\x r)}) -- (3*pi/4,0) -- cycle;
	\fill[fill=red] (9*pi/4,0) -- plot [domain=9*pi/4:11*pi/4] (\x,{sin(\x r)}) -- (11*pi/4,0) -- cycle; 
	\draw (5*pi/2,0.5) node(c) [draw] {1} ;
    \draw[color=blue]   plot (\x,{sin(\x r)})   node[right] {};
   
\end{tikzpicture}
\end{center}

\item Si en ese tiempo no se ha detectado señal, se supone situación de desintonizado.
\item Tras ejecutar el algoritmo de sintonización se reajusta la frecuencia y se vuelven a tomar capturas con el nuevo periodo supuesto.
\end{enumerate}


Realizar la medida en este punto tiene una ventaja importante sobre realizarla tras el multiplicador, y es la inmediatez tanto de la subida como de la caída de la señal. Por lo que la detección de la sintonización y de la desintonización sería inmediata.
\bigskip


\bigskip
\begin{itemize}
\item \textit{Ventajas:}

Rapidez en la detección tanto de sintonización como de desintonización.
\item \textit{Desventajas:}

Alta dificultad en la implementación.
\medskip
Poco nivel de tensión en la señal.
\end{itemize}


\bigskip

\subsubsection{Medida a la salida del multiplicador:}
\bigskip

En este punto tiene un nivel de continua alto. Del orden de la alimentación del \ac{MCU} (3-5V). Por lo tanto realizar la medida aquí es bastante simple.
\bigskip

Para realizar esta medida se pueden emplear dos módulos del \ac{MCU}:

\begin{enumerate}
\item \textbf{Conversor analógico/digital:} Convierte una señal analógica en una representación binaria de esa señal en 10 bits. Una vez obtenida se pude usar para estimar si es suficiente para considerar que el generador esta sintonizado.
\item \textbf{Comparador:} Se fija una tensión de referencia, y si la señal que se esta midiendo cae por debajo del umbral en algún momento, se puede considerar que el generador se ha desintonizado.
\end{enumerate}
\bigskip

\begin{itemize}
\item \textit{Ventajas:}

Facilidad en la captura y medida de la señal.
\item \textit{Desventajas:}

Poca capacidad de reacción a la caída de señal puesto que los condensadores que conforman el multiplicador impiden que el nivel de la señal baje o suba bruscamente.
\end{itemize}

\bigskip

\subsection{Algoritmos de sintonización:}
\bigskip


Para la implementación de estos algoritmos hay que tomar una serie de medida previas.
\begin{itemize}
\item Conocer la velocidad de giro del motor. (RPM) 
\item Conocer el paso del tornillo sinfín. Es decir, cuantos giros corresponden al desplazamiento de una unidad lineal, este caso el milímetro, a su paso por la tuerca del sintonizador.
\end{itemize}

Conociendo estos datos se puede relacionar el tiempo del excitación del motor con la longitud desplazada por el sintonizador.
\begin{equation}
L=r.p.m * paso * t
\label{cap6:equ:motor}
\end{equation}

\bigskip

$L:$ Longitud recorrida por el sintonizador.

$r.p.m:$ Revoluciones por minuto del motor.

$paso:$ Paso del tornillo sin fin. Distancia entre dos crestas de la rosca. Es la relación entre una vuelta y la distancia que se desplazaría si se estuviese enroscando.

$t:$ Tiempo de excitación del motor.
\bigskip

El tornillo empleado para este proyecto es de métrica 4, con un paso de 0.7mm. (\ref{cap6:subsec:sinfin}).
\bigskip

La implementación de uno u otro de estos algoritmos va a ser la que determine la eficiencia de del sistema. De esta manera según sea el entorno se usarán unos u otros como se explicará a continuación.


\subsubsection{Algoritmos no predictivos}

Como se mencionó en la sección \ref{cap6:subsec:propone_sinto} este tipo de algoritmos se empleará en entornos donde las frecuencias de las vibraciones sigan una distribución mas o menos uniforme, es decir, no haya unas mas probables que otras. De esta manera cuando se ha detectado la desintonización, la probabilidad de encontrar la nueva frecuencia de trabajo se reparte uniformemente a lo largo de toda la lámina.
\bigskip

Para la ejecución de este tipo de algoritmos basta con saber la distancia que se quiere mover el sintonizador en cada iteración y aplicar la formula \ref{cap6:equ:motor} para conocer el tiempo que se tiene que activar la salida correspondiente del \ac{MCU}.
\bigskip

De esta manera se simplifica la programación de los dos tipos vistos, el lineal y el alternante.
\bigskip

\textbf{\underline{Ejemplo:}}

Con el motor 212-008 (\ref{cap6:subsubsec:disponibles}) alimentado a 2,5V se obtienen 42rpm.

Por lo tanto si se quiere desplazar el sintonizador 1mm habría que alimentarlo durante:
$$t=L*\frac{1}{paso}*\frac{1}{rpm}$$
$$t=1*\frac{1}{0.7}*\frac{1}{42}$$
$$t=0.03 minutos=2.04segundos$$

Implementando esta simple formula en el \ac{MCU}, se pueden ejecutar los algoritmos no predictivos.

\subsubsection{Algoritmos predictivos}

Estos algoritmos son mas complicados de implementar que los anteriores.

Son útiles cuando el ambiente puede ser modelado y se pueden encontrar unas frecuencias características de él.

En este caso el \ac{MCU} iría recorriendo las frecuencias mas usuales hasta dar con la correcta.

Para esto además de la formula anterior habría que implementar la de la frecuencia de resonancia. (\ref{cap6:equation:fresonancia})
\bigskip

La ejecución será como sigue:

\begin{enumerate}
\item Calibración.
\item Detección de desintonización.
\item Búsqueda en memoria de la  siguiente frecuencia con mayor probabilidad.
\item Aplicación de la formula \ref{cap6:equation:fresonancia} para calcular la distancias que hay que desplazar el sintonizador a partir de la frecuencia origen.
\item Aplicación de la formula \ref{cap6:equ:motor}  para calcular el tiempo de excitación del motor en función de la distancia a recorrer.
\item Comprobar sintonización. Si aun no esta en sintonía, buscar en la siguiente frecuencia mas probable.
\end{enumerate}

Para que se pueda emplear este método el \ac{MCU} tiene que conocer en todo momento la frecuencia a la que está trabajando el sistema.
\bigskip

\underline{Calibración:}

La calibración es una parte fundamental de estos algoritmos. Es la encargada de que el \ac{MCU} conozca en cada momento la frecuencia de trabajo. Al inicializar el algoritmo, el sintonizador se desplazaría a una posición fija para la cual el \ac{MCU} conoce la frecuencia que corresponde.
\bigskip

Esto se implementa mediante un sensor fin de carrera que active el sintonizador al colocarse en determinada posición. A partir de este momento el \ac{MCU} fija la frecuencia a determinado valor, que será el correspondiente a esa posición. Esto es posible puesto que el generador es de dimensiones fijas, por lo que el sintonizador en una posición determinada siempre asegura la misma frecuencia de resonancia en la lámina.



\section{Placa PCB desarrollada para integrar la electrónica ``MC1''}
\label{cap6:sec:placa}
Como se deduce de la sección \ref{cap6:sec:electronica}, en la PCB desarrollada se incluirá un \ac{MCU} PIC 16LF1503, un driver de motores DRV8833 y un array de Darlingtons ULN2003A.
\begin{figure}[!h]
        \centering
		\includegraphics[width=0.7\textwidth]{Imagenes/imagenes/cap6/esquema_placa}  
        \caption{Esquema de la estructura de la placa.}
        \label{fig:cap6:esque_placa}
\end{figure}
\FloatBarrier


\subsection{Pines compartidos entre los controladores}

Puesto que no es necesario que estén los dos controladores conectados a la vez, pueden compartir pines del \ac{MCU}. Esto facilita la comprensión del sistema y facilita la implementación de los algoritmos en el \ac{MCU} puesto que independientemente del motor y del controlador que haya conectado, este siempre usa los mismo pines de salida.

Para que puedan compartir los pines, se incluye un mutiplexor cuadruple 2:1.

Este multiplexor tiene internamente 4 multiplexores 2:1. A cada uno de estos multiplexores internos se le conecta uno de los 4 pines del \ac{MCU} utilizados, y a las salidas se conectan los controladores.
\begin{figure}[!h]
        \centering
		\includegraphics[width=0.3\textwidth]{Imagenes/imagenes/cap6/mux}  
        \caption{Conexión de los multiplexores}
        \label{fig:cap6:esque_placa}
\end{figure}
\FloatBarrier



\subsection{Partes de la placa}


Llegados a este punto tenemos el esquema básico de la PCB en la figura \ref{fig:cap6:placa}.
\begin{figure}[!h]
        \centering
		\includegraphics[width=0.8\textwidth]{Imagenes/imagenes/cap6/esquema_placa2}  
        \caption{Esquema detallado de las conexiones principales}
        \label{fig:cap6:placa}
\end{figure}
\FloatBarrier
Y aqui una representación de la placa finalizada.
\begin{figure}[!h]
        \centering
		\includegraphics[width=0.8\textwidth]{Imagenes/imagenes/cap6/placa}  
        \caption{Representación de la placa diseñada}
        \label{fig:cap6:placa}
\end{figure}
\FloatBarrier

Los componentes principales son:
\begin{itemize}
\item \textit{U1:} DRV8833: Driver de motores de corriente continua y Bipolares.
\item \textit{U2:} ULN2003A: Driver de motores unipolares.
\item \textit{U3:} TS3A44159: Quad-Multiplexor 2:1.
\item \textit{U4:} PIC 16LF1503: \ac{MCU}.
\item \textit{S1:} Micro-pulsador.
\item \textit{P1:} Puerto de conexión de los motores DC y bipolares.
\item \textit{P2:} Puerto de conexión de los motores unipolares.
\item \textit{P3:} Switch de selección del multiplexor.
\item \textit{P4:} Puerto para la medida de las salidas del PIC.
\item \textit{ALIM:} Puerto para alimentación de la placa y los motores.
\item \textit{D1:} \ac{LED} indicador de encendido de la placa.
\item \textit{D2:} \ac{LED} indicador de potencia en los motores.
\end{itemize}






\subsubsection{Puerto para programación del PIC}

En la parte inferior izquierda de la placa esta situado el puerto para la programación del PIC, es un conector RJ 11. 

Puesto que esta placa esta concebida como una plataforma de pruebas para experimentar con distintos algoritmos, es un requisito básico que sea fácil cargar los programas desarrollados en el \ac{MCU}.

La herramienta utilizada para esto es el \ac{ICD3} que ofrece un puerto RJ 11 para la conexión con el PIC.

Esta herramienta se verá en profundidad en su sección correspondiente. \ref{cap9:sec:icd3}.


%\includegraphics{pdf/strain.pdf}
% Variable local para emacs, para  que encuentre el fichero maestro de
% compilación y funcionen mejor algunas teclas rápidas de AucTeX
%%%
%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../Tesis.tex"
%%% End:
